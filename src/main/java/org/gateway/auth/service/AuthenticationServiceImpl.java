package org.gateway.auth.service;

import lombok.AllArgsConstructor;
import org.gateway.auth.enums.AuthConstants;
import org.gateway.auth.model.dto.login.LoginRequestDTO;
import org.gateway.auth.model.dto.login.LoginResponseDTO;
import org.gateway.auth.model.dto.register.RegisterDTO;
import org.gateway.auth.model.dto.logout.LogoutRequestDTO;
import org.gateway.auth.model.entity.UserEntity;
import org.gateway.auth.token.JwtTokenService;
import org.gateway.common.exception.apiEx.ResponseModel;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Objects;

@Service
@AllArgsConstructor
@Transactional(readOnly = true)
public class AuthenticationServiceImpl implements AuthenticationService {

	private final UserService userService;
	private final ValidateRegister validateRegister;
	private final PasswordEncoder passwordEncoder;
	private final AuthenticationManager authenticationManager;
	private final JwtTokenService jwtTokenService;

	@Override
	@Transactional
	public ResponseEntity<ResponseModel> registerAccount(RegisterDTO request) {
		final boolean usernameExist = userService.isUsernameExist(request.getUsername());
		final String hashedPassword = passwordEncoder.encode(request.getPassword());
		final String role = request.getRole();

		if (!isRegisterDTOValid(request)) {
			return ResponseEntity
					.status(400)
					.body(ResponseModel
							.builder()
							.success(Boolean.FALSE)
							.data("Invalid register data")
							.build()
					);
		} else if (usernameExist) {
			return ResponseEntity
					.badRequest()
					.body(ResponseModel
							.builder()
							.success(Boolean.FALSE)
							.data("Username already exist")
							.build()
					);
		} else {
			final UserEntity userEntity = UserEntity
					.builder()
					.username(request.getUsername())
					.password(hashedPassword)
					.role(role)
					.createdAt(new Date())
					.updatedAt(new Date())
					.build();
			userService.saveUser(userEntity);
		}
		return ResponseEntity
				.ok()
				.body(ResponseModel
						.builder()
						.success(Boolean.TRUE)
						.data("User registered successfully")
						.build()
				);
	}

	@Override
	public ResponseEntity<ResponseModel> login(LoginRequestDTO request) {

		String username = request.getUsername();
		String password = request.getPassword();

		UserEntity userEntity = userService.findByUsername(username);
		ResponseModel responseModel = new ResponseModel();


		if (Objects.isNull(userEntity)) {
			responseModel.setSuccess(Boolean.FALSE);
			responseModel.setData("User %s not found" + username);
			return ResponseEntity
					.badRequest()
					.body(responseModel);
		}

//		if (!passwordEncoder.matches(password, userEntity.getPassword())) {
//			responseModel.setSuccess(Boolean.FALSE);
//			responseModel.setData("Password is incorrect");
//			return ResponseEntity
//					.badRequest()
//					.body(responseModel);
//		}

		// Get role from useEntity

		Authentication authentication = new UsernamePasswordAuthenticationToken(request.getUsername(), request.getPassword(),
				userService.getAuthorities(List.of(userEntity.getRole()))
		);

		Authentication authenticate = authenticationManager.authenticate(authentication);
		Map<String, String> tokens = jwtTokenService.generateTokens(authenticate, userEntity);

		return ResponseEntity
				.ok()
				.body(ResponseModel
						.builder()
						.success(Boolean.TRUE)
						.data(LoginResponseDTO
								.builder()
								.accessToken(tokens.get(AuthConstants.ACCESS_TOKEN))
								.refreshToken(tokens.get(AuthConstants.REFRESH_TOKEN))
								.build())
						.build()
				);
	}

	@Override
	public ResponseEntity<ResponseModel> logout(LogoutRequestDTO request) {
		return null;
	}

	@Override
	public ResponseEntity<ResponseModel> autoGeneratedPassword() {
		return null;
	}

	private boolean isRegisterDTOValid(RegisterDTO registerDTO) {
//		return Objects.nonNull(registerDTO)
//				&& Objects.nonNull(registerDTO.getUsername())
//				&& Objects.nonNull(registerDTO.getPassword())
//				&& Objects.nonNull(registerDTO.getRoleName());
		return Objects.nonNull(registerDTO)
				&& validateRegister.validateUsername(registerDTO.getUsername())
				&& validateRegister.validatePassword(registerDTO.getPassword())
				&& validateRegister.validateRoleName(registerDTO.getRole());
	}


}
